#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys
import random
import socket


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright 2013, Faraday Project"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class MedusaParser(object):
    """
    The objective of this class is to parse an xml file generated by the medusa tool.

    @param medusa_filepath A proper simple report generated by medusa
    """
    def __init__(self, medusa_filepath):
        self.filepath = medusa_filepath
        self.srv = {'ftp':'21','http':'80','imap':'143','mssql':'1433','mysql':'3306','ncp':'524','nntp':'119',
                    'pcanywhere':'5631','pop3':'110','postgres':'5432','rexec':'512','rlogin':'513','rsh':'514',
                    'smbnt':'smbnt','smtp':'25','smtp-vrfy':'smtp-vrfy','snmp':'161','ssh':'22','svn':'3690',
                    'telnet':'23','vmauthd':'vmauthd','vnc':'5900','web-form':'web-form','wrapper':'wrapper'}

        with open(self.filepath,"r") as f:
            lines = f.readlines()
            self.items = []
            for l in lines:
                                                                                          
                reg = re.search("ACCOUNT FOUND: \[([^$]+)\] Host: ([^$]+) User: ([^$]+) Password: ([^$]+) \[SUCCESS\]\n",l)
                                                                                                                 
                if reg:
                    item = {'service' : reg.group(1), 'host' : reg.group(2), 'user' : reg.group(3),
                            'pass' : reg.group(4)}
                    
                    print "ITEM" + str(item)
                    item['ip'] = self.getAddress(item['host'])
                    item['port']=self.srv[item['service']]
                    print "ITEM" + str(item)
                    self.items.append(item)

                                    

    def getAddress(self, hostname):
        """
        Returns remote IP address from hostname.
        """
        try:
            return socket.gethostbyname(hostname)
        except socket.error, msg:
            return hostname



class MedusaPlugin(core.PluginBase):
    """
    Example plugin to parse medusa output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Medusa"
        self.name            = "Medusa Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "2.1.1"
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(sudo medusa|sudo \.\/medusa|medusa|\.\/medusa).*?')
        self.host = None
        self.port =""

        self._completition = {
                                "":"Syntax: Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]",
                                "-h":"[TEXT] Target hostname or IP address",
                                "-H":"[FILE] File containing target hostnames or IP addresses",
                                "-u":"[TEXT] Username to test",
                                "-U":"[FILE] File containing usernames to test",
                                "-p":"[TEXT] Password to test",
                                "-P":"[FILE] File containing passwords to test",
                                "-C":"[FILE] File containing combo entries. See README for more information.",
                                "-O":"[FILE] File to append log information to",
                                "-e":"[n/s/ns] Additional password checks ([n] No Password, [s] Password = Username)",
                                "-M":"[TEXT] Name of the module to execute (without the .mod extension)",
                                "-m":"[TEXT] Parameter to pass to the module. This can be passed multiple times with a",
                                "-m":"-m Param1 -m Param2, etc.)",
                                "-d":"Dump all known modules",
                                "-n":"[NUM] Use for non-default TCP port number",
                                "-s":": Enable SSL",
                                "-g":"[NUM] Give up after trying to connect for NUM seconds (default 3)",
                                "-r":"[NUM] Sleep NUM seconds between retry attempts (default 3)",
                                "-R":"[NUM] Attempt NUM retries before giving up. The total number of attempts will be NUM + 1.",
                                "-t":"[NUM] Total number of logins to be tested concurrently",
                                "-T":"[NUM] Total number of hosts to be tested concurrently",
                                "-L":"Parallelize logins using one username per thread. The default is to process ",
                                "-f":"Stop scanning host after first valid username/password found.",
                                "-F":"Stop audit after first valid username/password found on any host.",
                                "-b":"Suppress startup banner",
                                "-q":"Display module's usage information",
                                "-v":"[NUM] Verbose level [0 - 6 (more)]",
                                "-w":"[NUM] Error debug level [0 - 10 (more)]",
                                "-V":": Display version",
                                "-Z":": Resume scan based on map of previous scan",     
        }

        global current_path
        self.output_path = os.path.join(self.data_path,
                                             "medusa_output-%s.txt" % self._rid)
        
                                  


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        
                                                                  
            
        if debug:
            parser = MedusaParser(output)
        else:
            if not os.path.exists(self.output_path):
                return False
            
            parser = MedusaParser(self.output_path)

            for item in parser.items:
                h_id = self.createAndAddHost(item['ip'])
                if self._isIPV4(item['ip']):
                    i_id = self.createAndAddInterface(h_id, item['ip'], ipv4_address=item['ip'],hostname_resolution=item['host'])
                else:
                    i_id = self.createAndAddInterface(h_id, item['ip'], ipv6_address=item['ip'],hostname_resolution=item['host'])
                
                port = self.port if self.port else item['port']
                
                s_id = self.createAndAddServiceToInterface(h_id,i_id,item['service'],ports=[port],protocol="tcp",status="open")
                
                self.createAndAddCredToService(h_id,s_id, item['user'],item['pass'])
            
        del parser
        
        if not debug:
            os.remove(self.output_path)
        return True

    xml_arg_re = re.compile(r"^.*(-O\s*[^\s]+).*$")
    def processCommandString(self, username, current_path, command_string):

        self.port=""
        self.output_path=os.path.join(self.data_path,"medusa_output-%s.txt" % random.uniform(1,10))        
        arg_match = self.xml_arg_re.match(command_string)
        
        mreg=re.search(r"\-n( |)([\d]+)",command_string)
        if mreg:
            self.port=mreg.group(2)

        if arg_match is None:
            return re.sub(r"(^.*?medusa?)",r"\1 -O %s" % self.output_path,command_string)
        else:
            return re.sub(arg_match.group(1),
                          r"-O %s" % self.output_path,
                          command_string)
    
    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False

    def setHost(self):
        pass


def createPlugin():
    return MedusaPlugin()

if __name__ == '__main__':
    parser = MedusaParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item
